---
layout: post
title: "How I, a project manager, have acquired programming skills"
date: 2015-07-28
categories: coding
crossposted: svbtle
---

I had been working on a business side of software development for over 8 years, but once woke up with a decision in mind: I have to know how to code myself.

A little disclaimer: I got my BS in Computer Science back in 2009, so my knowledge wasn't completely zero and, at the starting point, was quite fresh. On the other hand, I had a little handicap: I was a young father with old brain. But who'd ever not give a try, right?

## Why should a project manager bother to code

Being able to code is a useful skill for a lower-bound manager (e.g. project manager). It helps think more practically about budget, project scope, cost estimations and their projections on the effort of team members. Before that, one is like "Who'd ever spend 40 hours on that? Let it be 8!". After that, one is like "Okay, you say you need 40 hours but do you dedicate this time solely to execution of the task or do you include initial research and pre-merge testing, too?".

You see, it's a good skill to put things in their places. It makes a manager a bit more realistic and discovers those tiny little tasks that inevitably occurs but sometimes are overlooked by developers themselves.

Of course, a project manager, augmented with coding skills, may be risky. This role requires supervising progress in a bigger context. Too much details equals too much distraction, and distraction means less focused commitment. So I'd recommend either not overdoing it or admitting that the life will never be the same (so will position).

## How would a project manager evolve the coding skills

If you asked this question ten years ago, it would sound serious. Today, however, it's a shame to even let it out of mouth. Although, the problem inverted, and so it should be addressed the proper way.

In general, I'd recommend learning to code either by watching screencasts or by coding. The latter, although sounds strange, has actually never been easier.

## Resources that provide video lectures on coding

I've chosen several educational resources and focused on them. I didn't completely ignore other sources that are available, however those didn't seem good enough for me in certain aspects.

### Coursera

Coursera is the motherland of all massive open online courses. It all has started from Coursera, and I still remember the first time I saw a post somewhere between Inc. Magazine and HBR. Author of that post claimed that MOOCs are so great new students hardly will go to established university anymore. Of course, things don't turn that fast. We'll see.

Coursera is not basically a technology-oriented courseware platform. It has very broad variety of courses, mostly 1xx, for newbies and ones who haven't encountered the topics much in their lives. However, on Coursera, several useful courses have places, among them

* Cryptography I and II,
* Algorithms I and II,
* Analytic Combinatorics, and
* Analysis of Algorithms

Cryptography is purely theoretical, and Algorithms is stuffed with a lot of Java code. Since Java is a pretty straightforward language that boasts syntactical redundancy, all the examples are readable and can easily be ported to other languages.

### Egghead

[Egghead](http://egghead.io) is a gem. If you are just starting out as a programmer or want to sharpen your skills, this is a one stop resource to learn about latest tips, all things web development. And since web development is huge industry and has a lot in common with mobile applications and complex systems development, one will be happy to have those bite-sized chunks of knowledge.

### Udacity

Udacity is active with their Nanodegree programs. I see this idea useful but it costs around $200 per month and has a flexible trek that can stretch to months. I wasn't particularly ready for such investment so I decided to pass this opportunity, however Nanodegree alumni periodically appear who are happy with their new jobs in Fortune 500's and Silicon Valley startups.

### edX

MIT's edX isn't an engineering-focused platform, same as Coursera. But there are some interesting courses. Those are good for those who are just starting out (or re-starting, as in my case). So I'd recommend to take a look around there.

### Udemy

At first, I didn't want to put Udemy on this list. Most of the courses one can find on Udemy are of relatively low quality. The platform itself hasn't switched to HTML5 yet, so hello Flash and bye-bye MacBook's battery. I removed the Flash plugin and ceased my Udemy membership.

But on Udemy, there are a bunch of particularly unique and extremely high-quality courses that are produced by [Frontend Masters](https://www.udemy.com/u/frontendmasters/), [Packt Publishing](https://www.udemy.com/u/packtpublishing/). Seth Godin puts his courses there, too, although these are entrepreneurship-related, thus out of scope of this publication.

## Resources that provide hands-on practical tasks

Video courses done, next comes practice. I wholeheartedly believe that one cannot have experience from books, but just learn things. And things that have been learned but not applied seem to evaporate fast.

There aren't many resources that helps gain some practical experience in coding, but it may be solely for the reason I didn't purposefully search for them.

### Codecademy

Codecademy is #1 place to start. It's free and it offers a lot of interesting courses, each both dedicated to certain programming language and certain real-world problem, and the higher the level, the more applicable to life problems become.

I learned Ruby basics on Codecademy and, right after that, Rails 4 fundamentals. In total, I spent 3 days. Still can't believe such result can be achievable by any other method.

The good thing is that one is supposed to write code, a lot of it. After a while, it becomes annoying. To overcome this feeling, one should remember that repetitive tasks are proven way to gain basic skills and knowledge. So I don't see any problem in repeating code. The point is not to copy-paste by all means, otherwise in the end of the day it's just wasted time.

### HackerRank

A relatively fresh coding challenges platform. Thousands of programmers solve coding problems and compete with each other both in common leaderboard and in recurring challenges.

One can pick any programming language out of a long list of supported ones to solve problems. Each problem can be solved unlimited times with any language, no restrictions there.

The code should fit into run-time restrictions, typically 10 seconds and `O(N^3)` time complexity. For easy tasks, it's not a problem. For difficult and expert-level tasks a simple brute-force approach simply doesn't work, and the code quickly runs out of resources.

Before HackerRank, I used other platforms, but ended up there because the experience is so smooth and the problems are interesting.

### Codility

Codility is elite. TopTal uses Codility to assess their applicants' problem solving skills. It pretty much resembles HackerRank, but code execution cases and results are pretty obscure so one not only should check for edge cases and errors in code, but also deeply investigate reasons why the code failed at some test cases.

### ClojureScript Koans

I found it recently, after reading a book on ClojureScript. Back in student days, I've done a lot of interesting things with LISP, and since then I've been permanently in love with functional programming and with round brackets in particular.

So check out [ClojureScript Koans](http://clojurescriptkoans.com). The site is a step-by-step guide that doesn't explain ClojureScript or functional programming skills but rather makes its students search for the answer themselves. So wise!

### Various fiddles

There are plenty of playgrounds around the web. You can either experiment with your own things or, if possible, watch the results of other members. It inspires and sometimes helps discover interesting tricks.

Like,

* [JSFiddle](http://jsfiddle.net),
* [CodePen](http://codepen.io),
* [ES6 Fiddle](http://es6fiddle.net),
* [Ruby Fiddle](http://rubyfiddle.com), and so on.

Just google "*any language* fiddle".

## Too much, tho?

Getting into new field isn't easy. I'm feeling a lot like I felt 10 years ago as a first-year student. The problem is, I don't have the advantages of being a student anymore. As a student and also a young person, I could sleep less than 5 hours for months in a row without productivity loss, and I wasn't very busy with a family, full-time job, side gigs and other inevitable activities (however, I had always succeeded at burning time for useless deeds). So I basically use the simple formula I've come up with after a considerable period of time and continuous effort:

1. As a student, I had about 16 hours per day, 4–8 of them busy with study, so I could spend 8–12 hours on self-improvement. As an adult, I have about 4 hours per day for the same activities.
1. As a student, I wasn't very much exposed to unexpected turns and risks. As an adult, I fix things all the time.
1. As a student, I was bound to certain deadlines all the time. Now I set my own and adjust continuously, so it's not bad and it's not a failure if I don't finish something by the planned date, as long as it's education (thus, important but not urgent).

This helps me stay sane and not aspire after quick results.

## The next step

There are many alternative directions that, more or less, require my attention and presence. Among them,

* try to get a formal artifact of accomplishment, be it a certificate or a diploma,
* try to narrow and boost skills development by taking a big side project (preferably as a part of development team),
* go breadth-first and train problem solving skills and applied coding (thanks HackerRank for the considerable meaningful contribution),
* go depth-first and train certain super-narrow applied skills, like data visualization or artificial neural networks (my top 2, next fave after LISP),
* team up with more experienced developers and start a small business, so I would apply my business skills as well as develop technical skills incidentally,
* start a small side project to — at long last! — scratch my own itches.

After prioritizing a bit, I yielded an intermediate solution, half data-driven and another half purely on emotions. So I'm (very slowly) starting a new project that would help myself at first. The idea lays somewhere between sleeping and logging. Will check in at it soon, hopefully.