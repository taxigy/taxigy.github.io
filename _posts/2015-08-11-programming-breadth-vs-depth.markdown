---
layout: post
title: "Programming languages: breadth vs depth"
date: 2015-08-11
crossposted: svbtle
---

In a role-playing game, the player faces a choice: should the character develop more skills or deeper skills? Skill points are always limited. In learning, it's the same. You always have less resources than it's desirable and sometimes even necessary to finish all the tasks perfectly. So, in an oversimplificated model, there are two alternatives: go broad or go deep.

# Coding challenges and contests: breadth
There are various coding challenges out there. I'd reduce them into two major categories: "solve it fast" and "pretend it's a product".

Solve-it-fasts are mostly short challenges that require application of a certain algorithm and, generally, consist of a single problem. Reversing a linked list is a classical one. Matrix manipulations, tree traversals, graph searches, you name it.

The purpose of such a challenge is to discover whether you know how to apply a narrowly fixed pool of algorithms and data structures to solve particular problem. So if you don't, it's a matter of few hours to master it and maybe even solve in several different ways.

There may be time boundaries, and often are. Thus one should be thoroughly prepared to participate in such a challenge. Preparedness here means that one is familiar with Computer Science fundamentals and basic vocabulary and may apply these using one or more programming languages. Mastery in language itself is not required.

If you pick a random coding problem from the universe of them, it's likely there's a programming language which includes features that allow the problem to get solved quicker than in case of other languages. Thus, you have to know many programming languages.

Still, mastery is optional.

The broader your knowledge, the more you know *why* one programming language is better at solving a certain problem domain than the other, the more likely you'll succeed at solving those problems. Breadth matters.

# Real-world production problems: depth
In the real world, however, it's different. When you work on a product, you inevitably have investment (input) you have to return (output). So you have to not only balance between working and non-working state but also include end users and all the product team in this equation.

In reality, revenue matters. And revenue means customers want to pay because they are satisfied (or, because they are locked-in). So, most of the time, you don't actually have to implement a perfect algorithm to achieve this goal. It even may sometimes cause extra costs that won't return, and there's a word for that: perfectionism.

But in general, product problems are narrow and specific, and the solution lies deep. So you have to dig deep, and sometimes a lot deeper than before, which helps you discover little secrets and strengthen your skill. Here, depth matters.

# Hackathons: ?
There's also a hybrid case: hackathons. Those a very popular precisely for this feature. The point is, when you're attending a hackathon, it's expected from you to both be quick and deliver a usable product (a prototype, actually).

And this is where confusion comes from. In average, a programmer may be T-shaped, which means both broad but superficial, and deep but narrow knowledge. What hackathons expect, though, is a square-shaped (â–¢-shaped) person: broad and deep knowledge at the same time.

This is what many people are limited at. And this is the main purpose of such an endeavor: to push boundaries and rebuild one's constraints. To go either deeper or broader, depending on what area is least developed.

----

Becoming a square-shaped professional takes time, a lot of it. And it often doesn't return back. But *trying* to become one really does.